package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/google/uuid"
	"github.com/jxsr12/oldegg/config"
	"github.com/jxsr12/oldegg/graph/model"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Products is the resolver for the products field.
func (r *categoryResolver) Products(ctx context.Context, obj *model.Category) ([]*model.Product, error) {
	db := config.GetDB()

	var models []*model.Product

	return models, db.Where("category_id = ?", obj.ID).Find(&models).Error
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.NewProduct, shopID string) (*model.Product, error) {
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "No auth token",
		}
	}

	db := config.GetDB()
	id := uuid.NewString()
	groupId := uuid.NewString()

	group := &model.ProductGroup{
		ID: groupId,
	}
	db.Create(group)

	model := &model.Product{
		ID:          id,
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Discount:    input.Discount,
		Metadata:    input.Metadata,
		CategoryID:  input.CategoryID,
		ShopID:      shopID,
		BrandID:     input.BrandID,
		GroupID:     groupId,
		Stock:       input.Stock,
		CreatedAt:   time.Now(),
	}

	return model, db.Create(model).Error
}

// CreateProductVariant is the resolver for the createProductVariant field.
func (r *mutationResolver) CreateProductVariant(ctx context.Context, input model.NewProduct, groupID string) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: CreateProductVariant - createProductVariant"))
}

// CreateProductImage is the resolver for the createProductImage field.
func (r *mutationResolver) CreateProductImage(ctx context.Context, image string, productID string) (*model.ProductImage, error) {
	db := config.GetDB()
	model := &model.ProductImage{
		ID:        uuid.NewString(),
		Image:     image,
		ProductID: productID,
	}

	return model, db.Create(model).Error
}

// CreateProductImages is the resolver for the createProductImages field.
func (r *mutationResolver) CreateProductImages(ctx context.Context, images []string, productID string) (bool, error) {
	db := config.GetDB()
	for _, img := range images {
		model := &model.ProductImage{
			ID:        uuid.NewString(),
			Image:     img,
			ProductID: productID,
		}
		err := db.Create(model).Error

		if err != nil {
			return false, err
		}
	}
	return true, nil
}

// CreateBrand is the resolver for the createBrand field.
func (r *mutationResolver) CreateBrand(ctx context.Context, name string, logo string) (*model.ProductBrand, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "No auth token",
		}
	}

	id := uuid.NewString()
	model := &model.ProductBrand{
		ID:   id,
		Name: name,
		Logo: logo,
	}

	return model, db.Create(model).Error
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, name string) (*model.Category, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "No auth token",
		}
	}

	id := uuid.NewString()
	model := &model.Category{
		ID:   id,
		Name: name,
	}

	return model, db.Create(model).Error
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, input model.NewProduct, lastUpdateID *string) (*model.Product, error) {
	db := config.GetDB()
	product := new(model.Product)
	now := time.Now()
	err := db.First(product, "id = ?", *lastUpdateID).Error
	if err != nil {
		return nil, err
	}
	product.ValidTo = &now

	err = db.Save(product).Error
	if err != nil {
		return nil, err
	}

	model := &model.Product{
		ID:          uuid.NewString(),
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Discount:    input.Discount,
		Metadata:    "",
		CategoryID:  product.CategoryID,
		ShopID:      product.ShopID,
		Stock:       input.Stock,
		CreatedAt:   now,
	}

	return model, db.Create(model).Error
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, productID string) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: DeleteProduct - deleteProduct"))
}

// Images is the resolver for the images field.
func (r *productResolver) Images(ctx context.Context, obj *model.Product) ([]*model.ProductImage, error) {
	db := config.GetDB()

	var images []*model.ProductImage

	return images, db.Where("product_id = ?", obj.ID).Find(&images).Error
}

// Shop is the resolver for the shop field.
func (r *productResolver) Shop(ctx context.Context, obj *model.Product) (*model.Shop, error) {
	db := config.GetDB()

	model := new(model.Shop)

	return model, db.Where("id = ?", obj.ShopID).First(model).Error
}

// Group is the resolver for the group field.
func (r *productResolver) Group(ctx context.Context, obj *model.Product) (*model.ProductGroup, error) {
	db := config.GetDB()

	model := new(model.ProductGroup)

	return model, db.Where("id = ?", obj.GroupID).First(model).Error
}

// Brand is the resolver for the brand field.
func (r *productResolver) Brand(ctx context.Context, obj *model.Product) (*model.ProductBrand, error) {
	db := config.GetDB()

	brand := new(model.ProductBrand)

	return brand, db.First(brand, "id = ?", obj.BrandID).Error
}

// Category is the resolver for the category field.
func (r *productResolver) Category(ctx context.Context, obj *model.Product) (*model.Category, error) {
	db := config.GetDB()

	cat := new(model.Category)

	return cat, db.First(cat, "id = ?", obj.CategoryID).Error
}

// Reviews is the resolver for the reviews field.
func (r *productResolver) Reviews(ctx context.Context, obj *model.Product) ([]*model.Review, error) {
	db := config.GetDB()

	var reviews []*model.Review
	if err := db.Where("product_id = ?", obj.ID).Find(&reviews).Error; err != nil {
		return nil, err
	}

	return reviews, nil
}

// Product is the resolver for the product field.
func (r *productImageResolver) Product(ctx context.Context, obj *model.ProductImage) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: Product - product"))
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*model.Category, error) {
	panic(fmt.Errorf("not implemented: Category - category"))
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context, limit *int) ([]*model.Category, error) {
	panic(fmt.Errorf("not implemented: Categories - categories"))
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*model.Product, error) {
	db := config.GetDB()
	product := new(model.Product)

	return product, db.Where("id = ?", id).Limit(1).Find(&product).Error
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, shopID *string, limit *int, offset *int, input *model.SearchProduct, topSold *bool) ([]*model.Product, error) {
	db := config.GetDB()

	var models []*model.Product
	if topSold != nil && *topSold {
		return models, db.Raw("SELECT p.id, name, description, price, discount, metadata, category_id, shop_id, created_at, stock, valid_to FROM transaction_details td JOIN products p ON p.id = td.product_id  GROUP BY product_id, p.id ORDER BY SUM(quantity) DESC").Scan(&models).Error
	}

	if shopID != nil && limit != nil && offset != nil {
		fmt.Printf("limit: %d\n", *limit)
		return models, db.Where("shop_id = ?", shopID).Where("(valid_to IS NULL OR valid_to = '" + os.Getenv("MIN_DATE") + "')").Limit(*limit).Offset(*offset).Find(&models).Error
	}

	temp := db.Where("(valid_to IS NULL)")

	if input != nil {
		if input.IsDiscount != nil && *input.IsDiscount {
			temp = temp.Order("discount DESC").Limit(15)
		} else {
			if input.HighRating != nil && *input.HighRating {
				temp = temp.Select("products.id, name, products.description, price, discount, metadata, category_id, shop_id, products.created_at, stock, valid_to").Joins("JOIN reviews ON products.id = reviews.product_id").Group("products.id").Having("AVG(reviews.rating) >= 4")
			}
			if input.MinPrice != nil {
				temp = temp.Where("price >= ?", *input.MinPrice)
			}
			if input.MaxPrice != nil {
				temp = temp.Where("price <= ?", *input.MaxPrice)
			}
			if input.Keyword != nil {
				temp = temp.Where("(name LIKE ? OR products.description LIKE ?)", "%"+*input.Keyword+"%", "%"+*input.Keyword+"%")
			}
			if input.CategoryID != nil {
				temp = temp.Where("category_id = ?", *input.CategoryID)
			}
			if input.BrandID != nil {
				temp = temp.Where("brand_id = ?", *input.BrandID)
			}
			if input.ExceptID != nil {
				temp = temp.Where("id != ?", *input.ExceptID)
			}
			if input.OrderBy != nil {
				if *input.OrderBy == "newest" {
					temp = temp.Order("products.created_at DESC")
				} else if *input.OrderBy == "highest-price" {
					temp = temp.Order("price DESC")
				} else if *input.OrderBy == "lowest-price" {
					temp = temp.Order("price ASC")
				}
			}

			if input.CreatedAtRange != nil {
				temp = temp.Where("DATEDIFF(NOW(), products.created_at) <= ?", *input.CreatedAtRange)
			}

		}
	}

	if limit != nil {
		temp = temp.Limit(*limit)
	}

	if offset != nil {
		temp = temp.Offset(*offset)

	}

	return models, temp.Find(&models).Error
}

// Brands is the resolver for the brands field.
func (r *queryResolver) Brands(ctx context.Context, topSold bool) ([]*model.ProductBrand, error) {
	db := config.GetDB()

	var models []*model.ProductBrand
	if !topSold {
		return models, db.Find(&models).Error
	} else {
		return models, db.Raw("SELECT FROM transaction_details td JOIN products p ON p.id = td.product_id  GROUP BY product_id, p.id ORDER BY SUM(quantity) DESC").Scan(&models).Error
	}
}

// Category returns CategoryResolver implementation.
func (r *Resolver) Category() CategoryResolver { return &categoryResolver{r} }

// Product returns ProductResolver implementation.
func (r *Resolver) Product() ProductResolver { return &productResolver{r} }

// ProductImage returns ProductImageResolver implementation.
func (r *Resolver) ProductImage() ProductImageResolver { return &productImageResolver{r} }

type categoryResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type productImageResolver struct{ *Resolver }
