package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/jxsr12/oldegg/config"
	"github.com/jxsr12/oldegg/graph/model"
	"github.com/jxsr12/oldegg/service"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"gorm.io/gorm"
)

// CheckoutCart is the resolver for the checkoutCart field.
func (r *mutationResolver) CheckoutCart(ctx context.Context, shipmentTypeID string, paymentMethodID string, addressID string, distance float64) (*model.TransactionHeader, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var carts []*model.Cart
	err := db.Where("user_id = ?", userID).Find(&carts).Error
	if err != nil || carts == nil {
		return nil, &gqlerror.Error{
			Message: "Error, cart gaada",
		}
	}

	header := &model.TransactionHeader{
		ID:              uuid.NewString(),
		Date:            time.Now(),
		UserID:          userID,
		ShipmentID:      shipmentTypeID,
		PaymentMethodID: paymentMethodID,
		Status:          "OPEN",
		AddressID:       addressID,
	}

	err = db.Create(header).Error

	if err != nil {
		return header, &gqlerror.Error{
			Message: "Error creating transaction header",
		}
	}

	orderValue := 0.00

	for _, cart := range carts {
		detail := &model.TransactionDetail{
			TransactionHeaderID: header.ID,
			ProductID:           cart.ProductID,
			Quantity:            cart.Quantity,
			Notes:               "None",
		}

		product := new(model.Product)
		if err := db.First(product, "id = ?", cart.ProductID).Error; err != nil {
			return nil, err
		}
		product.Stock -= cart.Quantity

		orderValue += (product.Price * (100 - product.Discount) / 100) * float64(cart.Quantity)

		if err := db.Save(product).Error; err != nil {
			return nil, err
		}

		err = db.Create(detail).Error

		if err != nil {
			return header, &gqlerror.Error{
				Message: "Error, create detail",
			}
		}

		err = db.Delete(cart).Error
		if err != nil {
			return header, &gqlerror.Error{
				Message: "Error, delete cart",
			}
		}

		// Create ReviewCredit entity for each product
		reviewCredit := &model.ReviewCredit{
			ProductID: cart.ProductID,
			UserID:    userID,
		}
		if err := db.Create(reviewCredit).Error; err != nil {
			return header, &gqlerror.Error{
				Message: "Error creating review credit",
			}
		}
	}

	shipment := new(model.Shipment)
	if err := db.First(shipment, "id = ?", shipmentTypeID).Error; err != nil {
		return nil, err
	}

	orderValue += shipment.Fee * distance

	user := new(model.User)
	if err := db.First(user, "id = ?", userID).Error; err != nil {
		return nil, err
	}

	newBalance := user.CreditBalance - float64(orderValue)

	err = db.Model(&model.User{}).Where("id = ?", userID).Update("credit_balance", newBalance).Error
	if err != nil {
		return header, &gqlerror.Error{
			Message: "Error, deducting balance",
		}
	}

	return header, nil
}

// CancelTransaction is the resolver for the cancelTransaction field.
func (r *mutationResolver) CancelTransaction(ctx context.Context, transactionID string) (*model.TransactionHeader, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var transactionHeader model.TransactionHeader
	err := db.Where("id = ?", transactionID).First(&transactionHeader).Error
	if err != nil {
		return nil, &gqlerror.Error{
			Message: "Error, transaction gaada",
		}
	}

	if transactionHeader.Status == "CANCELLED" {
		return nil, &gqlerror.Error{
			Message: "Error, transaction already cancelled",
		}
	}

	if transactionHeader.UserID != userID {
		// Check if the user has the shop that sells at least one of the products in the transaction detail.
		transactionDetails := []*model.TransactionDetail{}
		if err := db.Where("transaction_header_id = ?", transactionID).Find(&transactionDetails).Error; err != nil {
			return nil, err
		}

		hasShopProduct := false
		for _, transactionDetail := range transactionDetails {
			product := &model.Product{}
			if err := db.Where("id = ?", transactionDetail.ProductID).First(product).Error; err != nil {
				return nil, err
			}
			if product.ShopID == userID {
				hasShopProduct = true
				break
			}
		}
		if !hasShopProduct {
			return nil, &gqlerror.Error{
				Message: "Error, unauthorized access to transaction",
			}
		}
	}

	transactionHeader.Status = "CANCELLED"

	err = db.Save(&transactionHeader).Error
	if err != nil {
		return &transactionHeader, &gqlerror.Error{
			Message: "Error updating transaction",
		}
	}

	return &transactionHeader, nil
}

// CompleteTransaction is the resolver for the completeTransaction field.
func (r *mutationResolver) CompleteTransaction(ctx context.Context, transactionID string) (*model.TransactionHeader, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token not found",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	// Check if user has shop that sells at least one product in the transaction details
	shop, err := service.ShopGetByUserID(ctx, userID)
	if err != nil {
		return nil, &gqlerror.Error{
			Message: "Error getting user shop",
		}
	}

	var header model.TransactionHeader
	if err := db.First(&header, "id = ?", transactionID).Error; err != nil {
		return nil, &gqlerror.Error{
			Message: "Error getting transaction header",
		}
	}

	var details []model.TransactionDetail
	if err := db.Where("transaction_header_id = ?", transactionID).Find(&details).Error; err != nil {
		return nil, &gqlerror.Error{
			Message: "Error getting transaction details",
		}
	}

	hasProduct := false
	for _, detail := range details {
		product := new(model.Product)
		if err := db.First(product, "id = ?", detail.ProductID).Error; err != nil {
			return nil, &gqlerror.Error{
				Message: "Error getting product",
			}
		}

		if product.ShopID == shop.ID {
			hasProduct = true
			break
		}
	}

	if !hasProduct {
		return nil, &gqlerror.Error{
			Message: "Error, user is not authorized to complete transaction",
		}
	}

	if header.Status == "COMPLETED" {
		return &header, nil
	}

	if header.Status != "OPEN" {
		return nil, &gqlerror.Error{
			Message: "Error, transaction has already been cancelled",
		}
	}

	header.Status = "COMPLETED"
	if err := db.Save(&header).Error; err != nil {
		return nil, &gqlerror.Error{
			Message: "Error updating transaction status",
		}
	}

	return &header, nil
}

// CreateVoucher is the resolver for the createVoucher field.
func (r *mutationResolver) CreateVoucher(ctx context.Context, id string, value float64) (*model.CreditVoucher, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "No auth token",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID
	user, _ := service.UserGetByID(ctx, userID)

	if user.Role != model.UserRoleAdmin {
		return nil, &gqlerror.Error{
			Message: "Unauthorized to create voucher",
		}
	}

	voucher := &model.CreditVoucher{
		ID:    id,
		Value: value,
		Valid: true,
	}

	err := db.Create(voucher).Error
	if err != nil {
		return nil, err
	}

	return voucher, nil
}

// DeleteVoucher is the resolver for the deleteVoucher field.
func (r *mutationResolver) DeleteVoucher(ctx context.Context, id string) (bool, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return false, &gqlerror.Error{
			Message: "No auth token",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID
	user, _ := service.UserGetByID(ctx, userID)

	if user.Role != model.UserRoleAdmin {
		return false, &gqlerror.Error{
			Message: "Unauthorized to delete vouchers",
		}
	}

	if err := db.Delete(&model.CreditVoucher{}, "id = ?", id).Error; err != nil {
		return false, err
	}

	return true, nil
}

// RedeemVoucher is the resolver for the redeemVoucher field.
func (r *mutationResolver) RedeemVoucher(ctx context.Context, id string) (*model.CreditVoucher, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}
	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	// Retrieve the credit voucher with the given ID
	var voucher model.CreditVoucher
	if err := db.Where("id = ?", id).First(&voucher).Error; err != nil {
		return nil, err
	}

	// Check if the voucher is valid
	if voucher.Valid {
		// Begin a transaction
		tx := db.Begin()

		// Update the voucher's valid status to false
		if err := tx.Model(&voucher).Update("valid", false).Error; err != nil {
			tx.Rollback()
			return nil, err
		}

		// Update the user's credit balance with the voucher's value
		if err := tx.Model(&model.User{}).Where("id = ?", userID).UpdateColumn("credit_balance", gorm.Expr("credit_balance + ?", voucher.Value)).Error; err != nil {
			tx.Rollback()
			return nil, err
		}

		// Commit the transaction
		if err := tx.Commit().Error; err != nil {
			return nil, err
		}

		return &voucher, nil
	} else {
		return nil, &gqlerror.Error{
			Message: "Credit voucher is not valid",
		}
	}
}

// ShipmentType is the resolver for the shipmentType field.
func (r *queryResolver) ShipmentType(ctx context.Context, id string) (*model.Shipment, error) {
	panic(fmt.Errorf("not implemented: ShipmentType - shipmentType"))
}

// ShipmentTypes is the resolver for the shipmentTypes field.
func (r *queryResolver) ShipmentTypes(ctx context.Context) ([]*model.Shipment, error) {
	db := config.GetDB()

	var models []*model.Shipment
	return models, db.Find(&models).Error
}

// PaymentMethod is the resolver for the paymentMethod field.
func (r *queryResolver) PaymentMethod(ctx context.Context, id string) (*model.PaymentMethod, error) {
	panic(fmt.Errorf("not implemented: PaymentMethod - paymentMethod"))
}

// PaymentMethods is the resolver for the paymentMethods field.
func (r *queryResolver) PaymentMethods(ctx context.Context) ([]*model.PaymentMethod, error) {
	db := config.GetDB()

	var models []*model.PaymentMethod
	return models, db.Find(&models).Error
}

// TransactionHeaders is the resolver for the transactionHeaders field.
func (r *queryResolver) TransactionHeaders(ctx context.Context) ([]*model.TransactionHeader, error) {
	db := config.GetDB()

	var models []*model.TransactionHeader
	return models, db.Find(&models).Error
}

// UserOrders is the resolver for the userOrders field.
func (r *queryResolver) UserOrders(ctx context.Context) ([]*model.TransactionHeader, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}
	// Retrieve user ID from auth context
	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var models []*model.TransactionHeader
	return models, db.Where("user_id = ?", userID).Order("date DESC").Find(&models).Error
}

// ShopOrders is the resolver for the shopOrders field.
func (r *queryResolver) ShopOrders(ctx context.Context) ([]*model.TransactionHeader, error) {
	db := config.GetDB()

	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}
	// Retrieve user ID from auth context
	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID
	shop, _ := service.ShopGetByUserID(ctx, userID)

	// Join transaction_headers and transaction_details tables to get all headers with at least one detail sold by the shop
	var headers []*model.TransactionHeader
	err := db.Joins("JOIN transaction_details ON transaction_headers.id = transaction_details.transaction_header_id").
		Joins("JOIN products ON transaction_details.product_id = products.id").
		Where("products.shop_id = ?", shop.ID).
		Group("transaction_headers.id").
		Find(&headers).
		Error
	if err != nil {
		return nil, err
	}

	return headers, nil
}

func (r *queryResolver) GetLastTransID(ctx context.Context, userID string, shopID string) (string, error) {
	db := config.GetDB()
	// Verify user is authenticated
	if ctx.Value("auth") == nil {
		return uuid.NewString(), &gqlerror.Error{
			Message: "Unauthorized",
			Extensions: map[string]interface{}{
				"code": "UNAUTHORIZED",
			},
		}
	}

	// Query the database for the last transaction ID for the given user and shop
	var transID string
	if err := db.Model(&model.TransactionHeader{}).
		Joins("LEFT JOIN transaction_details ON transaction_details.transaction_header_id = transaction_headers.id").
		Joins("LEFT JOIN products ON transaction_details.product_id = products.id").
		Where("transaction_headers.user_id = ? AND products.shop_id = ?", userID, shopID).
		Order("transaction_headers.date DESC").
		Limit(1).
		Pluck("transaction_headers.id", &transID).
		Error; err != nil {
		return uuid.NewString(), nil
	}

	if len(transID) == 0 {
		return uuid.NewString(), nil
	}

	return transID, nil
}

// Vouchers is the resolver for the vouchers field.
func (r *queryResolver) Vouchers(ctx context.Context) ([]*model.CreditVoucher, error) {
	db := config.GetDB()

	var models []*model.CreditVoucher
	return models, db.Find(&models).Error
}

// TransactionHeader is the resolver for the transactionHeader field.
func (r *transactionDetailResolver) TransactionHeader(ctx context.Context, obj *model.TransactionDetail) (*model.TransactionHeader, error) {
	db := config.GetDB()
	th := new(model.TransactionHeader)

	return th, db.First(th, "id = ?", obj.TransactionHeaderID).Error
}

// Product is the resolver for the product field.
func (r *transactionDetailResolver) Product(ctx context.Context, obj *model.TransactionDetail) (*model.Product, error) {
	db := config.GetDB()
	th := new(model.TransactionHeader)

	err := db.First(th, "id = ?", obj.TransactionHeaderID).Error
	if err != nil {
		return nil, &gqlerror.Error{
			Message: "Error, header gak ada",
		}
	}

	product := new(model.Product)

	return product, db.FirstOrInit(product, "id = ? ", obj.ProductID).Error
}

// User is the resolver for the user field.
func (r *transactionHeaderResolver) User(ctx context.Context, obj *model.TransactionHeader) (*model.User, error) {
	db := config.GetDB()
	user := new(model.User)

	return user, db.First(user, "id = ?", obj.UserID).Error
}

// Shipment is the resolver for the shipment field.
func (r *transactionHeaderResolver) Shipment(ctx context.Context, obj *model.TransactionHeader) (*model.Shipment, error) {
	db := config.GetDB()
	shipping := new(model.Shipment)

	return shipping, db.First(shipping, "id = ?", obj.ShipmentID).Error
}

// PaymentMethod is the resolver for the paymentMethod field.
func (r *transactionHeaderResolver) PaymentMethod(ctx context.Context, obj *model.TransactionHeader) (*model.PaymentMethod, error) {
	db := config.GetDB()
	pm := new(model.PaymentMethod)

	return pm, db.First(pm, "id = ?", obj.PaymentMethodID).Error
}

// Address is the resolver for the address field.
func (r *transactionHeaderResolver) Address(ctx context.Context, obj *model.TransactionHeader) (*model.Address, error) {
	db := config.GetDB()
	address := new(model.Address)

	return address, db.First(address, "id = ?", obj.AddressID).Error
}

// TransactionDetails is the resolver for the transactionDetails field.
func (r *transactionHeaderResolver) TransactionDetails(ctx context.Context, obj *model.TransactionHeader) ([]*model.TransactionDetail, error) {
	db := config.GetDB()
	var models []*model.TransactionDetail

	return models, db.Where("transaction_header_id = ?", obj.ID).Find(&models).Error
}

// TransactionDetail returns TransactionDetailResolver implementation.
func (r *Resolver) TransactionDetail() TransactionDetailResolver {
	return &transactionDetailResolver{r}
}

// TransactionHeader returns TransactionHeaderResolver implementation.
func (r *Resolver) TransactionHeader() TransactionHeaderResolver {
	return &transactionHeaderResolver{r}
}

type transactionDetailResolver struct{ *Resolver }
type transactionHeaderResolver struct{ *Resolver }
