package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/jxsr12/oldegg/config"
	"github.com/jxsr12/oldegg/graph/model"
	"github.com/jxsr12/oldegg/service"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// User is the resolver for the user field.
func (r *cartResolver) User(ctx context.Context, obj *model.Cart) (*model.User, error) {
	db := config.GetDB()
	user := new(model.User)

	return user, db.First(user, "id = ?", obj.UserID).Error
}

// Product is the resolver for the product field.
func (r *cartResolver) Product(ctx context.Context, obj *model.Cart) (*model.Product, error) {
	db := config.GetDB()
	product := new(model.Product)

	return product, db.Where("id = ?", obj.ProductID).Order("valid_to ASC").Limit(1).Find(&product).Error
}

// CreateCart is the resolver for the createCart field.
func (r *mutationResolver) CreateCart(ctx context.Context, productID string, quantity int, notes string) (*model.Cart, error) {
	db := config.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	cart, _ := service.CartGetByUserProduct(ctx, userID, productID)

	if cart != nil {
		cart.Quantity += quantity
		cart.Notes = notes

		return cart, db.Save(cart).Error
	}
	return service.CartCreate(ctx, userID, productID, quantity, notes)
}

// UpdateCart is the resolver for the updateCart field.
func (r *mutationResolver) UpdateCart(ctx context.Context, productID string, quantity int, notes string) (*model.Cart, error) {
	db := config.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	cart, _ := service.CartGetByUserProduct(ctx, userID, productID)

	if cart == nil {
		return nil, &gqlerror.Error{
			Message: "Error, cart gaada",
		}
	}
	if quantity > 0 {
		cart.Quantity = quantity
		// cart.Notes = notes

		return cart, db.Save(cart).Error
	}
	return cart, db.Delete(cart).Error
}

// DeleteCart is the resolver for the deleteCart field.
func (r *mutationResolver) DeleteCart(ctx context.Context, productID string) (bool, error) {
	db := config.GetDB()
	if ctx.Value("auth") == nil {
		return false, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	model := new(model.Cart)
	if err := db.First(model, "user_id = ? AND product_id = ?", userID, productID).Error; err != nil {
		return false, err
	}

	return true, db.Delete(model).Error
}

// CreateWishlist is the resolver for the createWishlist field.
func (r *mutationResolver) CreateWishlist(ctx context.Context, title string, typeArg model.WishlistType) (*model.Wishlist, error) {
	db := config.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	userID := ctx.Value("auth").(*service.JwtCustomClaim).ID

	wishlist := new(model.Wishlist)

	if err := db.First(wishlist, "user_id = ? AND title = ?", userID, title); err == nil {
		return nil, &gqlerror.Error{
			Message: "Error, nama tidak unik",
		}
	}

	wishlist = &model.Wishlist{
		ID:           uuid.NewString(),
		UserID:       userID,
		WishlistType: typeArg,
		Title:        title,
	}

	return wishlist, db.Create(wishlist).Error
}

// CreateWishlistItem is the resolver for the createWishlistItem field.
func (r *mutationResolver) CreateWishlistItem(ctx context.Context, wishlistID string, productID string) (*model.WishlistItem, error) {
	panic(fmt.Errorf("not implemented: CreateWishlistItem - createWishlistItem"))
}

// DeleteWishlist is the resolver for the deleteWishlist field.
func (r *mutationResolver) DeleteWishlist(ctx context.Context, id string) (bool, error) {
	db := config.GetDB()
	if ctx.Value("auth") == nil {
		return false, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	model := new(model.Wishlist)
	if err := db.First(model, "id = ?", id).Error; err != nil {
		return false, err
	}

	return true, db.Delete(model).Error
}

// DeleteWishlistItem is the resolver for the deleteWishlistItem field.
func (r *mutationResolver) DeleteWishlistItem(ctx context.Context, wishlistID string, productID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteWishlistItem - deleteWishlistItem"))
}

// Cart is the resolver for the cart field.
func (r *queryResolver) Cart(ctx context.Context, productID string) (*model.Cart, error) {
	panic(fmt.Errorf("not implemented"))
}

// Carts is the resolver for the carts field.
func (r *queryResolver) Carts(ctx context.Context) ([]*model.Cart, error) {
	db := config.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	id := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var models []*model.Cart
	return models, db.Where("user_id = ?", id).Find(&models).Error
}

// Wishlists is the resolver for the wishlists field.
func (r *queryResolver) Wishlists(ctx context.Context) ([]*model.Wishlist, error) {
	db := config.GetDB()
	if ctx.Value("auth") == nil {
		return nil, &gqlerror.Error{
			Message: "Error, token gaada",
		}
	}

	id := ctx.Value("auth").(*service.JwtCustomClaim).ID

	var models []*model.Wishlist
	return models, db.Where("user_id = ?", id).Find(&models).Error
}

// Type is the resolver for the type field.
func (r *wishlistResolver) Type(ctx context.Context, obj *model.Wishlist) (model.WishlistType, error) {
	panic(fmt.Errorf("not implemented: Type - type"))
}

// User is the resolver for the user field.
func (r *wishlistResolver) User(ctx context.Context, obj *model.Wishlist) (*model.User, error) {
	db := config.GetDB()
	user := new(model.User)

	return user, db.First(user, "id = ?", obj.UserID).Error
}

// Wishlist is the resolver for the wishlist field.
func (r *wishlistItemResolver) Wishlist(ctx context.Context, obj *model.WishlistItem) (*model.Wishlist, error) {
	panic(fmt.Errorf("not implemented: Wishlist - wishlist"))
}

// Product is the resolver for the product field.
func (r *wishlistItemResolver) Product(ctx context.Context, obj *model.WishlistItem) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: Product - product"))
}

// Cart returns CartResolver implementation.
func (r *Resolver) Cart() CartResolver { return &cartResolver{r} }

// Wishlist returns WishlistResolver implementation.
func (r *Resolver) Wishlist() WishlistResolver { return &wishlistResolver{r} }

// WishlistItem returns WishlistItemResolver implementation.
func (r *Resolver) WishlistItem() WishlistItemResolver { return &wishlistItemResolver{r} }

type cartResolver struct{ *Resolver }
type wishlistResolver struct{ *Resolver }
type wishlistItemResolver struct{ *Resolver }
